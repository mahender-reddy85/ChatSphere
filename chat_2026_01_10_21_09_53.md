1. **You**: update your project to use PostgreSQL with Neon. Let's start by updating the essential files:

1. First, let's update db.js:
javascript
// backend/db.js
import pg from 'pg';
const { Pool } = pg;
// Create a new pool using the connection string from environment variables
export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false // Required for Neon's SSL
  }
});
// Test the database connection
export async function testConnection() {
  try {
    const client = await pool.connect();
    console.log('✅ Connected to PostgreSQL database');
    client.release();
    return true;
  } catch (error) {
    console.error('❌ Error connecting to PostgreSQL:', error);
    return false;
  }
}
// Export query function for convenience
export const query = (text, params) => pool.query(text, params);
2. Update server.js:
javascript
// backend/server.js
import express from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { testConnection } from './db.js';
import userRoutes from './routes/users.js';
import messageRoutes from './routes/messages.js';
import roomRoutes from './routes/rooms.js';
const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST']
  }
});
// Test database connection on startup
testConnection().then(isConnected => {
  if (!isConnected) {
    console.error('Failed to connect to database. Exiting...');
    process.exit(1);
  }
});
// Middleware
app.use(cors());
app.use(express.json());
// Routes
app.use('/api/users', userRoutes);
app.use('/api/messages', messageRoutes);
app.use('/api/rooms', roomRoutes);
// Socket.io connection
io.on('connection', (socket) => {
  console.log('New client connected:', socket.id);
  socket.on('joinRoom', ({ roomId, userId }) => {
    socket.join(roomId);
    console.log(`User ${userId} joined room ${roomId}`);
  });
  socket.on('sendMessage', ({ roomId, message }) => {
    io.to(roomId).emit('receiveMessage', message);
  });
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});
// Start server
const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
3. Update routes/rooms.js:
javascript
// backend/routes/rooms.js
import express from 'express';
import { query } from '../db.js';
const router = express.Router();
// Get all rooms
router.get('/', async (req, res) => {
  try {
    const result = await query('SELECT * FROM rooms');
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching rooms:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
// Create a room
router.post('/', async (req, res) => {
  const { name, type = 'group', privacy = 'public', createdBy } = req.body;
  try {
    const result = await query(
      'INSERT INTO rooms (name, type, privacy, created_by) VALUES ($1, $2, $3, $4) RETURNING *',
      [name, type, privacy, createdBy]
    );
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error('Error creating room:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
// Join a room
router.post('/:roomId/join', async (req, res) => {
  const { roomId } = req.params;
  const { userId } = req.body;
  try {
    // Check if user is already a member
    const existingMember = await query(
      'SELECT * FROM room_members WHERE room_id = $1 AND user_id = $2',
      [roomId, userId]
    );
    if (existingMember.rows.length > 0) {
      return res.status(400).json({ message: 'User already in room' });
    }
    // Add user to room
    await query(
      'INSERT INTO room_members (room_id, user_id) VALUES ($1, $2)',
      [roomId, userId]
    );
    res.json({ message: 'Joined room successfully' });
  } catch (err) {
    console.error('Error joining room:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
// Get room details
router.get('/:roomId', async (req, res) => {
  const { roomId } = req.params;
  try {
    const roomResult = await query('SELECT * FROM rooms WHERE id = $1', [roomId]);
    if (roomResult.rows.length === 0) {
      return res.status(404).json({ message: 'Room not found' });
    }
    const membersResult = await query(
      'SELECT u.* FROM users u JOIN room_members rm ON u.id = rm.user_id WHERE rm.room_id = $1',
      [roomId]
    );
    res.json({
      ...roomResult.rows[0],
      members: membersResult.rows
    });
  } catch (err) {
    console.error('Error fetching room details:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
export default router;
4. Update routes/messages.js:
javascript
// backend/routes/messages.js
import express from 'express';
import { query } from '../db.js';
const router = express.Router();
// Get messages for a room
router.get('/:roomId', async (req, res) => {
  const { roomId } = req.params;
  try {
    const result = await query(
      `SELECT m.*, u.name as author_name, u.profile_picture as author_avatar
       FROM messages m
       LEFT JOIN users u ON m.author_id = u.id
       WHERE m.room_id = $1
       ORDER BY m.created_at ASC`,
      [roomId]
    );
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching messages:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
// Send a message
router.post('/', async (req, res) => {
  const { roomId, authorId, text, type = 'text' } = req.body;
  try {
    const result = await query(
      `INSERT INTO messages (room_id, author_id, text, type)
       VALUES ($1, $2, $3, $4)
       RETURNING *`,
      [roomId, authorId, text, type]
    );
    
    // Emit the new message to all clients in the room
    req.app.get('io').to(roomId).emit('receiveMessage', result.rows[0]);
    
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error('Error sending message:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
export default router;
5. Update routes/users.js:
javascript
// backend/routes/users.js
import express from 'express';
import { query } from '../db.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
const router = express.Router();
// Register a new user
router.post('/register', async (req, res) => {
  const { name, email, password } = req.body;
  
  try {
    // Check if user already exists
    const userExists = await query('SELECT * FROM users WHERE email = $1', [email]);
    if (userExists.rows.length > 0) {
      return res.status(400).json({ message: 'User already exists' });
    }
    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    // Create user
    const result = await query(
      'INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id, name, email',
      [name, email, hashedPassword]
    );
    // Generate JWT
    const token = jwt.sign(
      { id: result.rows[0].id },
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );
    res.status(201).json({
      ...result.rows[0],
      token
    });
  } catch (err) {
    console.error('Error registering user:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
// Login user
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    // Check if user exists
    const result = await query('SELECT * FROM users WHERE email = $1', [email]);
    if (result.rows.length === 0) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const user = result.rows[0];
    // Check password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    // Generate JWT
    const token = jwt.sign(
      { id: user.id },
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );
    // Update last login
    await query('UPDATE users SET last_seen = NOW() WHERE id = $1', [user.id]);
    res.json({
      id: user.id,
      name: user.name,
      email: user.email,
      token
    });
  } catch (err) {
    console.error('Error logging in:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
// Get current user
router.get('/me', async (req, res) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No token, authorization denied' });
    }
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const result = await query(
      'SELECT id, name, email, profile_picture, is_online, last_seen FROM users WHERE id = $1',
      [decoded.id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error getting user:', err);
    res.status(500).json({ message: 'Server error' });
  }
});
export default router;
6. Update package.json:
json
{
  "name": "chat-backend",
  "version": "1.0.0",
  "description": "Backend for ChatSphere with PostgreSQL",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "migrate": "node scripts/migrate.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.11.3",
    "socket.io": "^4.7.4"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
7. Create a .env file:
DATABASE_URL=postgresql://USER:PASS@HOST/neondb?sslmode=require
JWT_SECRET=your_jwt_secret_here
PORT=3001
NODE_ENV=development
8. Create a migration script (scripts/migrate.js):
javascript
import { query } from '../db.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
async function runMigrations() {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    // Create users table
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        profile_picture TEXT,
        is_online BOOLEAN DEFAULT false,
        last_seen TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Create rooms table
    await client.query(`
      CREATE TABLE IF NOT EXISTS rooms (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        type VARCHAR(50) NOT NULL,
        privacy VARCHAR(50) NOT NULL,
        created_by INTEGER REFERENCES users(id),
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Create room_members table
    await client.query(`
      CREATE TABLE IF NOT EXISTS room_members (
        room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        joined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (room_id, user_id)
      )
    `);
    // Create messages table
    await client.query(`
      CREATE TABLE IF NOT EXISTS messages (
        id SERIAL PRIMARY KEY,
        room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
        author_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
        text TEXT,
        type VARCHAR(50) DEFAULT 'text',
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Create indexes
    await client.query('CREATE INDEX IF NOT EXISTS idx_messages_room_id ON messages(room_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_messages_author_id ON messages(author_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_members_room_id ON room_members(room_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_members_user_id ON room_members(user_id)');
    await client.query('COMMIT');
    console.log('✅ Database schema created successfully');
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('❌ Error creating database schema:', error);
    process.exit(1);
  } finally {
    client.release();
    process.exit(0);
  }
}
runMigrations();
9. Update .gitignore:
node_modules/
.env
.DS_Store
*.log
2. **You**: .
3. **You**: .